---
description: 根据自然语言特性描述创建或更新特性规格说明。
handoffs: 
  - label: 构建技术计划
    agent: speckit.plan
    prompt: 为此规格说明创建计划。我正在使用...构建
  - label: 澄清规格要求
    agent: speckit.clarify
    prompt: 澄清规格说明要求
    send: true
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前，您**必须**考虑用户输入（如果不为空）。

## 流程概要

用户在触发消息中在 `/speckit.specify` 后输入的文本**即**特性描述。假定您在此对话中始终可以访问它，即使 `{ARGS}` 在下面字面显示。除非用户提供了空命令，否则不要要求用户重复。

根据该特性描述，执行以下操作:

1. **生成简洁的短名称**（2-4个词）作为分支名:
   - 分析特性描述并提取最有意义的关键词
   - 创建一个2-4个词的短名称来概括特性的本质
   - 尽可能使用 动作-名词 格式（例如，"add-user-auth"、"fix-payment-bug"）
   - 保留技术术语和缩写词（OAuth2、API、JWT等）
   - 保持简洁但足够描述以便一目了然地理解该特性
   - 示例:
     - "我想添加用户认证" → "user-auth"
     - "为API实现OAuth2集成" → "oauth2-api-integration"
     - "创建分析仪表板" → "analytics-dashboard"
     - "修复支付处理超时错误" → "fix-payment-timeout"

2. **创建新分支前检查现有分支**:

   a. 首先，拉取所有远程分支以确保我们有最新信息:

      ```bash
      git fetch --all --prune
      ```

   b. 在所有来源中查找该短名称的最高特性编号:
      - 远程分支: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<短名称>$'`
      - 本地分支: `git branch | grep -E '^[* ]*[0-9]+-<短名称>$'`
      - 规格目录: 检查匹配 `specs/[0-9]+-<短名称>` 的目录

   c. 确定下一个可用编号:
      - 从所有三个来源中提取所有编号
      - 找到最高编号 N
      - 为新分支编号使用 N+1

   d. 使用计算出的编号和短名称运行脚本 `{SCRIPT}`:
      - 传递 `--number N+1` 和 `--short-name "你的短名称"` 以及特性描述
      - Bash 示例: `{SCRIPT} --json --number 5 --short-name "user-auth" "添加用户认证"`
      - PowerShell 示例: `{SCRIPT} -Json -Number 5 -ShortName "user-auth" "添加用户认证"`

   **重要**:
   - 检查所有三个来源（远程分支、本地分支、规格目录）以查找最高编号
   - 仅匹配具有确切短名称模式的分支/目录
   - 如果未找到具有此短名称的现有分支/目录，则从编号1开始
   - 每个特性只能运行此脚本一次
   - JSON在终端中作为输出提供 - 始终参考它以获取您要查找的实际内容
   - JSON输出将包含 BRANCH_NAME 和 SPEC_FILE 路径
   - 对于参数中的单引号，如"I'm Groot"，使用转义语法：例如 'I'\''m Groot'（或如果可能使用双引号："I'm Groot"）

3. 加载 `templates/spec-template.md` 以了解所需章节。

4. 遵循此执行流程:

    1. 从输入解析用户描述
       如果为空: 错误 "未提供特性描述"
    2. 从描述中提取关键概念
       识别: 参与者、操作、数据、约束
    3. 对于不清楚的方面:
       - 根据上下文和行业标准做出明智的猜测
       - 仅在以下情况下标记 [需要澄清: 具体问题]:
         - 该选择显著影响特性范围或用户体验
         - 存在多种合理的解释并具有不同的含义
         - 不存在合理的默认值
       - **限制: 总共最多3个 [需要澄清] 标记**
       - 按影响排序澄清优先级: 范围 > 安全/隐私 > 用户体验 > 技术细节
    4. 填写用户场景和测试部分
       如果没有明确的用户流程: 错误 "无法确定用户场景"
    5. 生成功能性要求
       每个要求必须可测试
       对未指定的细节使用合理的默认值（在假设部分记录假设）
    6. 定义成功标准
       创建可衡量的、与技术无关的结果
       包括定量指标（时间、性能、数量）和定性度量（用户满意度、任务完成度）
       每个标准必须在不知道实现细节的情况下可验证
    7. 识别关键实体（如果涉及数据）
    8. 返回: 成功（规格已准备好进行规划）

5. 使用模板结构将规格说明写入 SPEC_FILE，用从特性描述（参数）中派生的具体细节替换占位符，同时保留章节顺序和标题。

6. **规格说明质量验证**: 在编写初始规格后，根据质量标准对其进行验证:

   a. **创建规格质量检查清单**: 使用检查清单模板结构在 `FEATURE_DIR/checklists/requirements.md` 生成检查清单文件，包含这些验证项:

      ```markdown
      # 规格说明质量检查清单: [特性名称]
      
      **目的**: 在进行规划之前验证规格说明的完整性和质量
      **创建**: [日期]
      **特性**: [链接到 spec.md]
      
      ## 内容质量
      
      - [ ] 无实现细节（语言、框架、API）
      - [ ] 专注于用户价值和业务需求
      - [ ] 为非技术利益相关者编写
      - [ ] 所有必需章节已完成
      
      ## 要求完整性
      
      - [ ] 不再存在 [需要澄清] 标记
      - [ ] 要求可测试且明确
      - [ ] 成功标准可衡量
      - [ ] 成功标准与技术无关（无实现细节）
      - [ ] 所有验收场景已定义
      - [ ] 边界情况已识别
      - [ ] 范围明确界定
      - [ ] 依赖关系和假设已识别
      
      ## 特性准备度
      
      - [ ] 所有功能性要求都有明确的验收标准
      - [ ] 用户场景涵盖主要流程
      - [ ] 特性符合成功标准中定义的可衡量结果
      - [ ] 实现细节未泄漏到规格说明中
      
      ## 备注
      
      - 标记为不完整的项目需要在 `/speckit.clarify` 或 `/speckit.plan` 之前更新规格
      ```

   b. **运行验证检查**: 根据每个检查清单项目检查规格:
      - 对于每个项目，确定其通过或失败
      - 记录发现的具体问题（引用相关规格部分）

   c. **处理验证结果**:

      - **如果所有项目都通过**: 标记检查清单完成并进入步骤6

      - **如果项目失败（不包括 [需要澄清]）**:
        1. 列出失败项目和具体问题
        2. 更新规格以解决每个问题
        3. 重新运行验证直到所有项目通过（最多3次迭代）
        4. 如果3次迭代后仍然失败，在检查清单备注中记录剩余问题并警告用户

      - **如果保留 [需要澄清] 标记**:
        1. 从规格中提取所有 [需要澄清: ...] 标记
        2. **限制检查**: 如果存在超过3个标记，仅保留3个最关键的（按范围/安全/用户体验影响），并对其余部分做出明智的猜测
        3. 对于每个需要澄清的内容（最多3个），以此格式向用户提出选项:

           ```markdown
           ## 问题 [N]: [主题]
           
           **上下文**: [引用相关规格部分]
           
           **我们需要知道的**: [来自需要澄清标记的具体问题]
           
           **建议答案**:
           
           | 选项 | 答案 | 影响 |
           |------|------|------|
           | A    | [第一个建议答案] | [这对特性意味着什么] |
           | B    | [第二个建议答案] | [这对特性意味着什么] |
           | C    | [第三个建议答案] | [这对特性意味着什么] |
           | 自定义 | 提供您自己的答案 | [说明如何提供自定义输入] |
           
           **您的选择**: _[等待用户响应]_
           ```

        4. **关键 - 表格格式**: 确保markdown表格格式正确:
           - 使用一致的间距并对齐竖线
           - 每个单元格的内容周围应有空格: `| 内容 |` 而不是 `|内容|`
           - 标题分隔符必须至少有3个破折号: `|--------|`
           - 测试表格在markdown预览中正确呈现
        5. 按顺序编号问题（Q1、Q2、Q3 - 总共最多3个）
        6. 在等待响应之前一起呈现所有问题
        7. 等待用户响应所有问题的选择（例如，"Q1: A, Q2: 自定义 - [详情], Q3: B"）
        8. 通过将每个 [需要澄清] 标记替换为用户选择或提供的答案来更新规格
        9. 解决所有澄清后重新运行验证

   d. **更新检查清单**: 在每次验证迭代后，使用当前通过/失败状态更新检查清单文件

7. 报告完成情况，包括分支名称、规格文件路径、检查清单结果以及下一阶段的准备情况（`/speckit.clarify` 或 `/speckit.plan`）。

**注意:** 脚本在写入之前创建并检出新分支并初始化规格文件。

## 一般指南

## 快速指南

- 关注**什么**（用户需要什么）和**为什么**。
- 避免如何实现（不涉及技术栈、API、代码结构）。
- 为业务利益相关者编写，而不是开发人员。
- 不要创建嵌入在规格中的任何检查清单。那将是一个单独的命令。

### 章节要求

- **必需章节**: 每个特性都必须完成
- **可选章节**: 仅在与特性相关时包含
- 当章节不适用时，完全删除它（不要留作"N/A"）

### 用于AI生成

从用户提示创建此规格时:

1. **做出明智的猜测**: 使用上下文、行业标准和常见模式来填补空白
2. **记录假设**: 在假设部分记录合理的默认值
3. **限制澄清**: 最多3个 [需要澄清] 标记 - 仅用于以下关键决策:
   - 显著影响特性范围或用户体验
   - 具有不同含义的多种合理解释
   - 缺乏任何合理的默认值
4. **排序澄清优先级**: 范围 > 安全/隐私 > 用户体验 > 技术细节
5. **像测试人员一样思考**: 每个模糊的要求都应该未能通过"可测试且明确"的检查清单项目
6. **需要澄清的常见领域**（仅当不存在合理默认值时）:
   - 特性范围和边界（包括/排除特定用例）
   - 用户类型和权限（如果可能存在多种冲突解释）
   - 安全/合规要求（在法律/财务上重要时）

**合理默认值的示例**（不要询问这些）:

- 数据保留: 该领域的行业标准实践
- 性能目标: 除非指定，否则为标准web/移动应用期望
- 错误处理: 用户友好的消息和适当的回退
- 认证方法: 对于web应用的标准基于会话或OAuth2
- 集成模式: 除非另有说明，否则为RESTful API

### 成功标准指南

成功标准必须:

1. **可衡量**: 包括具体指标（时间、百分比、计数、率）
2. **与技术无关**: 不提及框架、语言、数据库或工具
3. **以用户为中心**: 从用户/业务角度描述结果，而不是系统内部
4. **可验证**: 可以在不知道实现细节的情况下进行测试/验证

**良好示例**:

- "用户可以在3分钟内完成结账"
- "系统支持10,000个并发用户"
- "95%的搜索在1秒内返回结果"
- "任务完成率提高40%"

**不良示例**（以实现为重点）:

- "API响应时间低于200毫秒"（过于技术化，使用"用户即时看到结果"）
- "数据库可以处理1000 TPS"（实现细节，使用面向用户的指标）
- "React组件高效渲染"（特定于框架）
- "Redis缓存命中率高于80%"（特定于技术）
